from typing import Any, ClassVar, Dict, Tuple

from typing import overload
import numpy
ASYNC_ENCODE_SUPPORT: NV_ENC_CAPS
BGR: PixelFormat
BIT_DEPTH_MINUS_8: NV_DEC_CAPS
BIT_DEPTH_NOT_SUPPORTED: TaskExecInfo
BT_601: ColorSpace
BT_709: ColorSpace
DYNAMIC_QUERY_ENCODER_CAPACITY: NV_ENC_CAPS
END_OF_STREAM: TaskExecInfo
EXACT_FRAME: SeekMode
EXPOSED_COUNT: NV_ENC_CAPS
FAIL: TaskExecInfo
H264: CudaVideoCodec
HEIGHT_MAX: NV_ENC_CAPS
HEIGHT_MIN: NV_ENC_CAPS
HEVC: CudaVideoCodec
HIST_COUNT_BINS: NV_DEC_CAPS
HIST_COUNT_BIT_DEPTH: NV_DEC_CAPS
IS_CODEC_SUPPORTED: NV_DEC_CAPS
IS_HIST_SUPPORTED: NV_DEC_CAPS
JPEG: ColorRange
LEVEL_MAX: NV_ENC_CAPS
LEVEL_MIN: NV_ENC_CAPS
MAX_HEIGHT: NV_DEC_CAPS
MAX_MB_COUNT: NV_DEC_CAPS
MAX_WIDTH: NV_DEC_CAPS
MB_NUM_MAX: NV_ENC_CAPS
MB_PER_SEC_MAX: NV_ENC_CAPS
MIN_HEIGHT: NV_DEC_CAPS
MIN_WIDTH: NV_DEC_CAPS
MORE_DATA_NEEDED: TaskExecInfo
MPEG: ColorRange
NO_PTS: int
NUM_MAX_BFRAMES: NV_ENC_CAPS
NUM_MAX_LTR_FRAMES: NV_ENC_CAPS
NUM_MAX_TEMPORAL_LAYERS: NV_ENC_CAPS
NV12: PixelFormat
OUTPUT_FORMAT_MASK: NV_DEC_CAPS
P10: PixelFormat
P12: PixelFormat
PREPROC_SUPPORT: NV_ENC_CAPS
PREV_KEY_FRAME: SeekMode
RGB: PixelFormat
RGB_32F: PixelFormat
RGB_32F_PLANAR: PixelFormat
RGB_PLANAR: PixelFormat
SEPARATE_COLOUR_PLANE: NV_ENC_CAPS
SUCCESS: TaskExecInfo
SUPPORTED_RATECONTROL_MODES: NV_ENC_CAPS
SUPPORT_10BIT_ENCODE: NV_ENC_CAPS
SUPPORT_ADAPTIVE_TRANSFORM: NV_ENC_CAPS
SUPPORT_ALPHA_LAYER_ENCODING: NV_ENC_CAPS
SUPPORT_BDIRECT_MODE: NV_ENC_CAPS
SUPPORT_BFRAME_REF_MODE: NV_ENC_CAPS
SUPPORT_CABAC: NV_ENC_CAPS
SUPPORT_CONSTRAINED_ENCODING: NV_ENC_CAPS
SUPPORT_CUSTOM_VBV_BUF_SIZE: NV_ENC_CAPS
SUPPORT_DYNAMIC_SLICE_MODE: NV_ENC_CAPS
SUPPORT_DYN_BITRATE_CHANGE: NV_ENC_CAPS
SUPPORT_DYN_FORCE_CONSTQP: NV_ENC_CAPS
SUPPORT_DYN_RCMODE_CHANGE: NV_ENC_CAPS
SUPPORT_DYN_RES_CHANGE: NV_ENC_CAPS
SUPPORT_EMPHASIS_LEVEL_MAP: NV_ENC_CAPS
SUPPORT_FIELD_ENCODING: NV_ENC_CAPS
SUPPORT_FMO: NV_ENC_CAPS
SUPPORT_HIERARCHICAL_BFRAMES: NV_ENC_CAPS
SUPPORT_HIERARCHICAL_PFRAMES: NV_ENC_CAPS
SUPPORT_INTRA_REFRESH: NV_ENC_CAPS
SUPPORT_LOOKAHEAD: NV_ENC_CAPS
SUPPORT_LOSSLESS_ENCODE: NV_ENC_CAPS
SUPPORT_MEONLY_MODE: NV_ENC_CAPS
SUPPORT_MONOCHROME: NV_ENC_CAPS
SUPPORT_MULTIPLE_REF_FRAMES: NV_ENC_CAPS
SUPPORT_QPELMV: NV_ENC_CAPS
SUPPORT_REF_PIC_INVALIDATION: NV_ENC_CAPS
SUPPORT_SAO: NV_ENC_CAPS
SUPPORT_STEREO_MVC: NV_ENC_CAPS
SUPPORT_SUBFRAME_READBACK: NV_ENC_CAPS
SUPPORT_TEMPORAL_AQ: NV_ENC_CAPS
SUPPORT_TEMPORAL_SVC: NV_ENC_CAPS
SUPPORT_WEIGHTED_PREDICTION: NV_ENC_CAPS
SUPPORT_YUV444_ENCODE: NV_ENC_CAPS
UDEF: ColorRange
UNDEFINED: PixelFormat
UNSPEC: ColorSpace
VP9: CudaVideoCodec
WIDTH_MAX: NV_ENC_CAPS
WIDTH_MIN: NV_ENC_CAPS
Y: PixelFormat
YCBCR: PixelFormat
YUV420: PixelFormat
YUV420_10bit: PixelFormat
YUV422: PixelFormat
YUV444: PixelFormat
YUV444_10bit: PixelFormat
FAIL: TaskExecInfo
SUCCESS: TaskExecInfo
END_OF_STREAM: TaskExecInfo
MORE_DATA_NEEDED: TaskExecInfo
BIT_DEPTH_NOT_SUPPORTED: TaskExecInfo

class TaskExecInfo:
    __members__: ClassVar[dict] = ...  # read-only
    FAIL: ClassVar[ColorRange] = ...
    SUCCESS: ClassVar[ColorRange] = ...
    END_OF_STREAM: ClassVar[ColorRange] = ...
    MORE_DATA_NEEDED: ClassVar[ColorRange] = ...
    BIT_DEPTH_NOT_SUPPORTED: ClassVar[ColorRange] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...    

class ColorRange:
    __members__: ClassVar[dict] = ...  # read-only
    JPEG: ClassVar[ColorRange] = ...
    MPEG: ClassVar[ColorRange] = ...
    UDEF: ClassVar[ColorRange] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorSpace:
    __members__: ClassVar[dict] = ...  # read-only
    BT_601: ClassVar[ColorSpace] = ...
    BT_709: ClassVar[ColorSpace] = ...
    UNSPEC: ClassVar[ColorSpace] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorspaceConversionContext:
    color_range: ColorRange
    color_space: ColorSpace
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, color_space: ColorSpace, color_range: ColorRange) -> None: ...

class CudaBuffer:
    def __init__(self, *args, **kwargs) -> None: ...
    def Clone(self) -> CudaBuffer: ...
    @overload
    def CopyFrom(self, other: CudaBuffer, context: int, stream: int) -> None: ...
    @overload
    def CopyFrom(self, other: CudaBuffer, gpu_id: int) -> None: ...
    def GetElemSize(self) -> int: ...
    def GetNumElems(self) -> int: ...
    def GetRawMemSize(self) -> int: ...
    def GpuMem(self) -> int: ...
    @classmethod
    def Make(cls, elem_size: int, num_elems: int, gpu_id: int) -> CudaBuffer: ...

class CudaVideoCodec:
    __members__: ClassVar[dict] = ...  # read-only
    H264: ClassVar[CudaVideoCodec] = ...
    HEVC: ClassVar[CudaVideoCodec] = ...
    VP9: ClassVar[CudaVideoCodec] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CuvidParserException(Exception): ...

class HwResetException(Exception): ...

class MotionVector:
    def __init__(self, *args, **kwargs) -> None: ...

class NV_DEC_CAPS:
    __members__: ClassVar[dict] = ...  # read-only
    BIT_DEPTH_MINUS_8: ClassVar[NV_DEC_CAPS] = ...
    HIST_COUNT_BINS: ClassVar[NV_DEC_CAPS] = ...
    HIST_COUNT_BIT_DEPTH: ClassVar[NV_DEC_CAPS] = ...
    IS_CODEC_SUPPORTED: ClassVar[NV_DEC_CAPS] = ...
    IS_HIST_SUPPORTED: ClassVar[NV_DEC_CAPS] = ...
    MAX_HEIGHT: ClassVar[NV_DEC_CAPS] = ...
    MAX_MB_COUNT: ClassVar[NV_DEC_CAPS] = ...
    MAX_WIDTH: ClassVar[NV_DEC_CAPS] = ...
    MIN_HEIGHT: ClassVar[NV_DEC_CAPS] = ...
    MIN_WIDTH: ClassVar[NV_DEC_CAPS] = ...
    OUTPUT_FORMAT_MASK: ClassVar[NV_DEC_CAPS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NV_ENC_CAPS:
    __members__: ClassVar[dict] = ...  # read-only
    ASYNC_ENCODE_SUPPORT: ClassVar[NV_ENC_CAPS] = ...
    DYNAMIC_QUERY_ENCODER_CAPACITY: ClassVar[NV_ENC_CAPS] = ...
    EXPOSED_COUNT: ClassVar[NV_ENC_CAPS] = ...
    HEIGHT_MAX: ClassVar[NV_ENC_CAPS] = ...
    HEIGHT_MIN: ClassVar[NV_ENC_CAPS] = ...
    LEVEL_MAX: ClassVar[NV_ENC_CAPS] = ...
    LEVEL_MIN: ClassVar[NV_ENC_CAPS] = ...
    MB_NUM_MAX: ClassVar[NV_ENC_CAPS] = ...
    MB_PER_SEC_MAX: ClassVar[NV_ENC_CAPS] = ...
    NUM_MAX_BFRAMES: ClassVar[NV_ENC_CAPS] = ...
    NUM_MAX_LTR_FRAMES: ClassVar[NV_ENC_CAPS] = ...
    NUM_MAX_TEMPORAL_LAYERS: ClassVar[NV_ENC_CAPS] = ...
    PREPROC_SUPPORT: ClassVar[NV_ENC_CAPS] = ...
    SEPARATE_COLOUR_PLANE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORTED_RATECONTROL_MODES: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_10BIT_ENCODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_ADAPTIVE_TRANSFORM: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_ALPHA_LAYER_ENCODING: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_BDIRECT_MODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_BFRAME_REF_MODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_CABAC: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_CONSTRAINED_ENCODING: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_CUSTOM_VBV_BUF_SIZE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_DYNAMIC_SLICE_MODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_DYN_BITRATE_CHANGE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_DYN_FORCE_CONSTQP: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_DYN_RCMODE_CHANGE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_DYN_RES_CHANGE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_EMPHASIS_LEVEL_MAP: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_FIELD_ENCODING: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_FMO: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_HIERARCHICAL_BFRAMES: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_HIERARCHICAL_PFRAMES: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_INTRA_REFRESH: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_LOOKAHEAD: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_LOSSLESS_ENCODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_MEONLY_MODE: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_MONOCHROME: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_MULTIPLE_REF_FRAMES: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_QPELMV: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_REF_PIC_INVALIDATION: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_SAO: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_STEREO_MVC: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_SUBFRAME_READBACK: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_TEMPORAL_AQ: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_TEMPORAL_SVC: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_WEIGHTED_PREDICTION: ClassVar[NV_ENC_CAPS] = ...
    SUPPORT_YUV444_ENCODE: ClassVar[NV_ENC_CAPS] = ...
    WIDTH_MAX: ClassVar[NV_ENC_CAPS] = ...
    WIDTH_MIN: ClassVar[NV_ENC_CAPS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PacketData:
    bsl: int
    dts: int
    duration: int
    key: int
    pos: int
    pts: int
    def __init__(self) -> None: ...

class PixelFormat:
    __members__: ClassVar[dict] = ...  # read-only
    BGR: ClassVar[PixelFormat] = ...
    NV12: ClassVar[PixelFormat] = ...
    P10: ClassVar[PixelFormat] = ...
    P12: ClassVar[PixelFormat] = ...
    RGB: ClassVar[PixelFormat] = ...
    RGB_32F: ClassVar[PixelFormat] = ...
    RGB_32F_PLANAR: ClassVar[PixelFormat] = ...
    RGB_PLANAR: ClassVar[PixelFormat] = ...
    UNDEFINED: ClassVar[PixelFormat] = ...
    Y: ClassVar[PixelFormat] = ...
    YCBCR: ClassVar[PixelFormat] = ...
    YUV420: ClassVar[PixelFormat] = ...
    YUV420_10bit: ClassVar[PixelFormat] = ...
    YUV422: ClassVar[PixelFormat] = ...
    YUV444: ClassVar[PixelFormat] = ...
    YUV444_10bit: ClassVar[PixelFormat] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PyBufferUploader:
    @overload
    def __init__(self, elem_size: int, num_elems: int, gpu_id: int) -> None: ...
    @overload
    def __init__(self, elem_size: int, num_elems: int, context: int, stream: int) -> None: ...
    def UploadSingleBuffer(self, array: numpy.ndarray[numpy.uint8]) -> CudaBuffer: ...

class PyCudaBufferDownloader:
    @overload
    def __init__(self, elem_size: int, num_elems: int, gpu_id: int) -> None: ...
    @overload
    def __init__(self, elem_size: int, num_elems: int, context: int, stream: int) -> None: ...
    def DownloadSingleCudaBuffer(self, buffer: CudaBuffer, array: numpy.ndarray[numpy.uint8]) -> bool: ...

class PyFFmpegDemuxer:
    @overload
    def __init__(self, input: str, opts: Dict[str,str]) -> None: ...
    @overload
    def __init__(self, input: str) -> None: ...
    def AvgFramerate(self) -> float: ...
    def Codec(self) -> CudaVideoCodec: ...
    def ColorRange(self) -> ColorRange: ...
    def ColorSpace(self) -> ColorSpace: ...
    @overload
    def DemuxSinglePacket(self, packet: numpy.ndarray[numpy.uint8]) -> bool: ...
    @overload
    def DemuxSinglePacket(self, packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8]) -> bool: ...
    def Format(self) -> PixelFormat: ...
    def Framerate(self) -> float: ...
    def Height(self) -> int: ...
    def IsVFR(self) -> bool: ...
    def LastPacketData(self, pkt_data: PacketData) -> None: ...
    def Numframes(self) -> int: ...
    def Seek(self, seek_ctx: SeekContext, pkt: numpy.ndarray[numpy.uint8]) -> bool: ...
    def Timebase(self) -> float: ...
    def Width(self) -> int: ...

class PyFfmpegDecoder:
    def __init__(self, input: str, opts: Dict[str,str], gpu_id: int = ...) -> None: ...
    def AvgFramerate(self) -> float: ...
    def Codec(self) -> CudaVideoCodec: ...
    def ColorRange(self) -> ColorRange: ...
    def ColorSpace(self) -> ColorSpace: ...
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8]) -> Tuple[bool,TaskExecInfo]: ...
    def DecodeSingleSurface(self, *args, **kwargs) -> Any: ...
    def Format(self) -> PixelFormat: ...
    def Framerate(self) -> float: ...
    def GetMotionVectors(self) -> numpy.ndarray[MotionVector]: ...
    def Height(self) -> int: ...
    def Numframes(self) -> int: ...
    def Timebase(self) -> float: ...
    def Width(self) -> int: ...

class PyFrameUploader:
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, gpu_id: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, context: int, stream: int) -> None: ...
    def Format(self) -> PixelFormat: ...
    def UploadSingleFrame(self, *args, **kwargs) -> Any: ...

class PyNvDecoder:
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, codec: CudaVideoCodec, gpu_id: int) -> None: ...
    @overload
    def __init__(self, input: str, gpu_id: int, opts: Dict[str,str]) -> None: ...
    @overload
    def __init__(self, input: str, gpu_id: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, codec: CudaVideoCodec, context: int, stream: int) -> None: ...
    @overload
    def __init__(self, input: str, context: int, stream: int, opts: Dict[str,str]) -> None: ...
    @overload
    def __init__(self, input: str, context: int, stream: int) -> None: ...
    def AvgFramerate(self) -> float: ...
    def Capabilities(self) -> Dict[NV_DEC_CAPS,int]: ...
    def ColorRange(self) -> ColorRange: ...
    def ColorSpace(self) -> ColorSpace: ...
    @overload
    def DecodeFrameFromPacket(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8]) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeFrameFromPacket(self, frame: numpy.ndarray[numpy.uint8], enc_packet_data: PacketData, packet: numpy.ndarray[numpy.uint8]) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeFrameFromPacket(self, frame: numpy.ndarray[numpy.uint8], enc_packet_data: PacketData, packet: numpy.ndarray[numpy.uint8], pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeFrameFromPacket(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8], pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], seek_context: SeekContext) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], seek_context: SeekContext, pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8]) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], seek_context: SeekContext) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def DecodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], seek_context: SeekContext, pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    def DecodeSingleSurface(self, *args, **kwargs) -> Any: ...
    def DecodeSurfaceFromPacket(self, enc_packet_data: PacketData, packet: numpy.ndarray[numpy.uint8], pkt_data: PacketData, bool_nvcv_check: bool) -> object: ...
    @overload
    def FlushSingleFrame(self, frame: numpy.ndarray[numpy.uint8]) -> Tuple[bool,TaskExecInfo]: ...
    @overload
    def FlushSingleFrame(self, frame: numpy.ndarray[numpy.uint8], pkt_data: PacketData) -> Tuple[bool,TaskExecInfo]: ...
    def FlushSingleSurface(self, *args, **kwargs) -> Any: ...
    def Format(self) -> PixelFormat: ...
    def Framerate(self) -> float: ...
    def Framesize(self) -> int: ...
    def Height(self) -> int: ...
    def IsVFR(self) -> bool: ...
    def LastPacketData(self, pkt_data: PacketData) -> None: ...
    def Numframes(self) -> int: ...
    def Timebase(self) -> float: ...
    def Width(self) -> int: ...

class PyNvEncoder:
    @overload
    def __init__(self, settings: Dict[str,str], gpu_id: int, format: PixelFormat = ..., verbose: bool = ...) -> None: ...
    @overload
    def __init__(self, settings: Dict[str,str], context: int, stream: int, format: PixelFormat = ..., verbose: bool = ...) -> None: ...
    def Capabilities(self) -> Dict[NV_ENC_CAPS,int]: ...
    @overload
    def EncodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], sync: bool, append: bool) -> bool: ...
    @overload
    def EncodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], sync: bool) -> bool: ...
    @overload
    def EncodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8], sync: bool) -> bool: ...
    @overload
    def EncodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8]) -> bool: ...
    @overload
    def EncodeSingleFrame(self, frame: numpy.ndarray[numpy.uint8], packet: numpy.ndarray[numpy.uint8]) -> bool: ...
    @overload
    def EncodeSingleSurface(self, nvcvimage: object, packet: numpy.ndarray[numpy.uint8], testbool: bool) -> bool: ...
    @overload
    def EncodeSingleSurface(self, surface, packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], sync: bool, append: bool) -> bool: ...
    @overload
    def EncodeSingleSurface(self, surface, packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8], sync: bool) -> bool: ...
    @overload
    def EncodeSingleSurface(self, surface, packet: numpy.ndarray[numpy.uint8], sync: bool) -> bool: ...
    @overload
    def EncodeSingleSurface(self, surface, packet: numpy.ndarray[numpy.uint8], sei: numpy.ndarray[numpy.uint8]) -> bool: ...
    @overload
    def EncodeSingleSurface(self, surface, packet: numpy.ndarray[numpy.uint8]) -> bool: ...
    def Flush(self, packets: numpy.ndarray[numpy.uint8]) -> bool: ...
    def FlushSinglePacket(self, packets: numpy.ndarray[numpy.uint8]) -> bool: ...
    def Format(self) -> PixelFormat: ...
    def GetFrameSizeInBytes(self) -> int: ...
    def Height(self) -> int: ...
    def Reconfigure(self, settings: Dict[str,str], force_idr: bool = ..., reset_encoder: bool = ..., verbose: bool = ...) -> bool: ...
    def Width(self) -> int: ...

class PySurfaceConverter:
    @overload
    def __init__(self, width: int, height: int, src_format: PixelFormat, dst_format: PixelFormat, gpu_id: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, src_format: PixelFormat, dst_format: PixelFormat, context: int, stream: int) -> None: ...
    def Execute(self, *args, **kwargs) -> Any: ...
    def Format(self) -> PixelFormat: ...

class PySurfaceDownloader:
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, gpu_id: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, context: int, stream: int) -> None: ...
    @overload
    def DownloadSingleSurface(self, surface, frame: numpy.ndarray[numpy.uint8]) -> bool: ...
    @overload
    def DownloadSingleSurface(self, surface, frame: numpy.ndarray[numpy.float32]) -> bool: ...
    @overload
    def DownloadSingleSurface(self, surface, frame: numpy.ndarray[numpy.uint16]) -> bool: ...
    def Format(self) -> PixelFormat: ...

class PySurfaceRemaper:
    @overload
    def __init__(self, x_map: numpy.ndarray[numpy.float32], y_map: numpy.ndarray[numpy.float32], format: PixelFormat, gpu_id: int) -> None: ...
    @overload
    def __init__(self, x_map: numpy.ndarray[numpy.float32], y_map: numpy.ndarray[numpy.float32], format: PixelFormat, context: int, stream: int) -> None: ...
    def Execute(self, *args, **kwargs) -> Any: ...
    def Format(self) -> PixelFormat: ...

class PySurfaceResizer:
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, gpu_id: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, format: PixelFormat, context: int, stream: int) -> None: ...
    def Execute(self, *args, **kwargs) -> Any: ...
    def Format(self) -> PixelFormat: ...

class SeekContext:
    mode: SeekMode
    out_frame_pts: int
    seek_frame: int
    seek_tssec: float
    @overload
    def __init__(self, seek_frame: int) -> None: ...
    @overload
    def __init__(self, seek_frame: int, mode: SeekMode) -> None: ...
    @overload
    def __init__(self, seek_ts: float) -> None: ...
    @overload
    def __init__(self, seek_ts: float, mode: SeekMode) -> None: ...
    @property
    def num_frames_decoded(self) -> int: ...

class SeekMode:
    __members__: ClassVar[dict] = ...  # read-only
    EXACT_FRAME: ClassVar[SeekMode] = ...
    PREV_KEY_FRAME: ClassVar[SeekMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Surface:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def Clone(self) -> Surface: ...
    @overload
    def Clone(self, gpu_id: int) -> Surface: ...
    @overload
    def Clone(self, context: int, stream: int) -> Surface: ...
    @overload
    def CopyFrom(self, other: Surface, gpu_id: int) -> None: ...
    @overload
    def CopyFrom(self, other: Surface, context: int, stream: int) -> None: ...
    @overload
    def Crop(self, x: int, y: int, w: int, h: int, gpu_id: int) -> Surface: ...
    @overload
    def Crop(self, x: int, y: int, w: int, h: int, context: int, stream: int) -> Surface: ...
    def Empty(self) -> bool: ...
    def Format(self) -> PixelFormat: ...
    def Height(self, plane: int = ...) -> int: ...
    def HostSize(self) -> int: ...
    @overload
    @classmethod
    def Make(cls, format: PixelFormat, width: int, height: int, gpu_id: int) -> Surface: ...
    @overload
    @classmethod
    def Make(cls, format: PixelFormat, width: int, height: int, context: int) -> Surface: ...
    def NumPlanes(self) -> int: ...
    def OwnMemory(self) -> bool: ...
    def Pitch(self, plane: int = ...) -> int: ...
    def PlanePtr(self, plane: int = ...) -> SurfacePlane: ...
    def Width(self, plane: int = ...) -> int: ...

class SurfacePlane:
    def __init__(self, *args, **kwargs) -> None: ...
    def ElemSize(self) -> int: ...
    @overload
    def Export(self, dst: int, dst_pitch: int, gpu_id: int) -> None: ...
    @overload
    def Export(self, dst: int, dst_pitch: int, context: int, stream: int) -> None: ...
    def GpuMem(self) -> int: ...
    def Height(self) -> int: ...
    def HostFrameSize(self) -> int: ...
    @overload
    def Import(self, src: int, src_pitch: int, gpu_id: int) -> None: ...
    @overload
    def Import(self, src: int, src_pitch: int, context: int, stream: int) -> None: ...
    def Pitch(self) -> int: ...
    def Width(self) -> int: ...

class TaskExecDetails:
    info: TaskExecInfo
    def __init__(self) -> None: ...

class TaskExecInfo:
    __members__: ClassVar[dict] = ...  # read-only
    BIT_DEPTH_NOT_SUPPORTED: ClassVar[TaskExecInfo] = ...
    END_OF_STREAM: ClassVar[TaskExecInfo] = ...
    FAIL: ClassVar[TaskExecInfo] = ...
    MORE_DATA_NEEDED: ClassVar[TaskExecInfo] = ...
    SUCCESS: ClassVar[TaskExecInfo] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def GetNumGpus() -> int: ...
def GetNvencParams() -> Dict[str,str]: ...
